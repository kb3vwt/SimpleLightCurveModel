<!DOCTYPE html>
<html>
<head>
<title>SLCTM Module Readme</title>
</head>
<body>

<h1>SLCTM: <u>S</u>imple <u>L</u>ight <u>C</u>urve <u>T</u>ransit <u>M</u>odel</h1>
<p>Currently, the <em>SLCTM.LightCurve</em> (Python 2.7) class encapsulates the orbital and transit parameters for
  a single planet. The class also provides storage for transit times, errors, fluxes
  and flux timestamps. In addition to the transit data, transit start/stop indices
  are saved. By importing the SLCTM module, you also gain access to a few functions that operate
  on a <em>SLCTM.LightCurve</em> object. This Readme gives some basic information on the class, with
  usage tips. Provided along with this documentation file are a few examples of
  how to use the class and the module's functions. You can find the project's
  github <a href="https://github.com/kb3vwt/SimpleLightCurveModel">here.</a> </p>

  <p> The batman module (<u>B</u>ad-<u>A</u>ss <u>T</u>ransit <u>M</u>odel C<u>a</u>lculatio<u>n</u>),
    developed by Laura Kreidberg is used this within the SLCTM module to create an ensemble of different
    models. The SLCTM module provides some custom wrapper functions for batman, but the LightCurve class
    is abstract enough to be extended to take data - simulated or otherwise - from any source.</p>

    <p>The emcee module developed by Dan Foreman-Mackey is used  to regress a function for the light curve</br></p>

    <p>Readme Last Edited: 2016/08/09</p>


<h2>Prerequisites</h2>
<p>The SLCTM Module requires some Python modules to be installed. You will want to
  import the following modules. If they need to be installed first, please do so.</p>
<ul>
  <li>math -- should be built in</li>
  <li>sys -- should be built in</li>
  <li><a href=http://www.numpy.org/>numpy</a> -- Get it from pip or easy_install</li>
  <li><a href=http://astro.uchicago.edu/~kreidberg/batman/quickstart.html> batman </a> -- Compile it from source </br> <a href</li>
  <li><a href= http://dan.iel.fm/emcee/current/>emcee</a> -- Get it from pip or easy_install</li>
</ul>


<h2>SLCTM Extensions</h2>
<p>Eventually, the SLCTM Module should include provisions for multiple planet transits, and a function to insert Kepler data into the LightCurve class.</p>

<h2>Acknowledgments</h2>
<p>The SLCTM Module was started by <a href="emailto:kb3vwt@gmail.com">Joseph Sheldon Jr</a> as part of a summer project supervised by Prof. Eric B. Ford. </br> Prof. Ford provided the initial idea and lots of advice/mentoring. </p>
<p>Credits to Laura Kreidberg for batman and to Dan Foreman-Mackey for emcee</p>
</br></br></br>


<h1>Module Description</h1>
<h2>Overview of SLCTM Module Components</h2>
<p>The SLCTM Module currently consists of a class and a set of functions that operate on the class. Follow the links below for more detail:</p>
<h3>Classes:</h3>
<ul>
  <li><a href="#LightCurve">SLCTM.LightCurve</a></li>
</ul>
<h3>Functions:</h3>
<ul>
  <li><a href="#TransTimes">SLCTM.PopTransTimes(SLCTM,n)</a></li>
  <li><a href="#DataGen">SLCTM.PopFluxesNaive_Data(SLCTM,BatmanParams,NFluxPoints)</a></li>
  <li><a href="#ModelGen">SLCTM.PopFluxesNaive_Model(MSLCTM,DSLCTM,BatmanParams)</a></li>
  <li><a href="#AddNoise">SLCTM.Add_Norm_LCnoise(SLCTM,lcnoise)</a></li>
  <li><a href="#ChiSqComp">SLCTM.ComputeChiSqInter(DataSLCTM,ModelSLCTM)</a></li>
</ul>

<i>Please Use links above (under "Overview of SLCTM Module Components") to navigate</i>
<h2>Classes</h2>
<h3><a name="LightCurve"></a>SLCTM.LightCurve</h3>
<p>The LightCurve object stores the following values:</p>
<table border=1>
<tr><td><b>Attribute</b></td>                       <td><b>Supposed Data Type</b></td>   <td><b>Description</b></td></tr>
<tr><td>SLCTM.LightCurve.t0</td>             <td>float</td>   <td>start time (time zero)</td></tr>
<tr><td>SLCTM.LightCurve.c1</td>             <td>float</td>   <td>TTV amplitude 1</td></tr>
<tr><td>SLCTM.LightCurve.c2</td>             <td>float</td>   <td>TTV amplitude 2</td></tr>
<tr><td>SLCTM.LightCurve.porb</td>           <td>float</td>   <td>Orbital period (days)</td></tr>
<tr><td>SLCTM.LightCurve.pttv</td>           <td>float</td>   <td>TTV period (days)</td></tr>
<tr><td>SLCTM.LightCurve.noisett_e</td>      <td>float</td>   <td>Noise factor on transit times</td></tr>
<tr><td>SLCTM.LightCurve.b</td>              <td>float</td>   <td>projected impact parameter</td></tr>
<tr><td>SLCTM.LightCurve.vtan</td>           <td>float</td>   <td>tangential velocity of planet</td></tr>
<tr><td>SLCTM.LightCurve.modelnumber</td>    <td>float</td>   <td>(optional) book-keeping variable for codes that require multiple models</td></tr>
<tr><td>SLCTM.LightCurve.transTimes[]</td>   <td>float list</td>   <td>individual transit times (days)</td></tr>
<tr><td>SLCTM.LightCurve.fluxTimes[]</td>    <td>float list</td>   <td>timestamp of flux point 'i' - indices shared with fluxes[] (days)</td></tr>
<tr><td>SLCTM.LightCurve.fluxes[]</td>       <td>float list</td>   <td>normalized flux at time 'i' - indices shared with fluxTimes[]</td></tr>
<tr><td>SLCTM.LightCurve.sigma[]</td>        <td>float list</td>   <td>error at flux piont 'i' - indices shared with fluxes[]</td></tr>
<tr><td>SLCTM.LightCurve.isNoisy</td>        <td>bool</td>   <td>book-keeping - set true if simulated or actual data</td></tr>
<tr><td>SLCTM.LightCurve.transitStartIndex[]</td>        <td>float list</td>   <td>start of transit 'i' - same indices as fluxTimes[]</td></tr>
<tr><td>SLCTM.LightCurve.transitEndIndex[]</td>        <td>float list</td>   <td>end of transit 'i' - same indices as fluxTimes[]</td></tr>
</table>

<p> The LightCurve object also includes a few member functions to quickly set orbital / transit parameters:</p>
<table border=1>
<tr><td>Attribute</td>                                                  <td>Description</td></tr>
<tr><td>SLCTM.LightCurve.SetModelParams(self,INDIC)</td>                <td>Sets orbital timing parameters - t0,c1,c2,porb,pttv,noisett_e,b,vtan</td></tr>
<tr><td>SLCTM.LightCurve.setBatmanParams(self,BatmanParams,BMIn)</td>   <td>Sets batman parameters - t0,per,rp,a,inc,ecc,w,u,limb_dark </td></tr>
</table>
<h4>SLCTM.LightCurve.SetModelParams(self,INDIC)</h4>
<p>SetModelParams takes a dictionary (INDIC) and applies its values to that of the
  light curve's object. By default, all of the values are set to 0.0 unless this function is called.
  The prototype dictonary is below. You may name it whatever you wish.
</p>
<pre><code>
  #SLCTM / Batman Initial Param Dictionaries:
  SLCTMInputParams = {
      't0': 0.0,
      'c1': 0.2,
      'c2':0.05,
      'porb':10.0,
      'pttv': 100,
      'noisett_e': 0.0001,
      'b':100.0,
      'vtan':200.0
  }
</code></pre>
<p>Individual values can be set by using the default dictionary syntax within Python:
<pre><code>
SLCTMInputParams['pttv'] = myPTTV
</pre></code>
This is useful if you're iteratively making an ensemble of models to compare data to.
For example code for making many models, see ex_chisqs.py.</p>

<h4>SLCTM.LightCurve.setBatmanParams(self,BatmanParams,BMIn)</h4>
<p>SetBatmanParams takes a dictionary (BMIn) and applies its values to that of the
  Batman's parameter object (BatmanParams) object. Strictly speaking, this function
  does not operate on our LightCurve object, however it is bundled within the object,
  for sake of consistency (Our other SetParams type function is a member function, too).
</p>
<pre><code>
BatmanInputParams = {
    't0': 0.0,
    'per':10.0,
    'rp':0.2,
    'a':12.0,
    'inc':90.0,
    'ecc':0.0,
    'w':90.0,
    'u1':0.1,
    'u2':0.3
}
</code></pre>
<p>Individual values can be set by using the default dictionary syntax within Python, as done with the SLCTMInputParams dictionary.

<h4>General Usage of the Class</h4>
<p>In general, the SLCTM.LightCurve class is made in batches. For a working example, see ex_chisqs.py. Below is an example of how to create a single light curve:</p>
<pre><code>
  #SLCTM / Batman Initial Param Dictionaries:
  SLCTMInputParams = {
      't0': 0.0,
      'c1': 0.2,
      'c2':0.05,
      'porb':10.0,
      'pttv': PTTV_Actual,
      'noisett_e': 0.0001,
      'b':100.0,
      'vtan':200.0
  }
  BatmanInputParams = {
      't0': 0.0,
      'per':10.0,
      'rp':0.2,
      'a':12.0,
      'inc':90.0,
      'ecc':0.0,
      'w':90.0,
      'u1':0.1,
      'u2':0.3
  }

  bmparams = batman.TransitParams() #Initialize Batman's native parameter object.
                                    #This is used for both the simulated data and
                                    #each model. Held constant under this test.

  #Create Simulated Data / Light Curve
  DataLightCurve = SLCTM.LightCurve() #Initialize a light curve for the simulated data.
  DataLightCurve.SetModelParams(SLCTMInputParams) #Set the Parameters by passing our parameter dictionary.
  DataLightCurve.setBatmanParams(bmparams,BatmanInputParams) #Set the batman parameters by passing our batman parameter dictionary.
  SLCTM.PopTransTimes(DataLightCurve,NUMBEROFTRANSITS) #Populate NUMBEROFTRANSITS transit times. This fills an array full of transit times.
  SLCTM.PopFluxesNaive_Data(DataLightCurve,bmparams,DATAPOINTSPERTRANSIT) #This populates each transit's light curve with a given number of points and generates the list of flux time points.
  SLCTM.Add_Norm_LCnoise(DataLightCurve,0.005) #This adds a simulated amount of noise to each data point. Sets LightCurve.isNoisy to true.
  #End of Processing Simulated Data
</pre></code>
<p> You will want to follow this example to create a simulated dataset of your own. To create a model with existing timestamps from a dataset, you should use the SLCTM.PopFluxesNaive_Model function rather than the
  SLCTM.PopFluxesNaive_Data function -- it doesn't generate new timestamps for the fluxes. Below is how you create a set of models with varying TTV periods:</p>
<pre><code>
  #Compute Models:
  LightCurves = [SLCTM.LightCurve() for i in range(len(PTTV_arr))] #Create a Model Light Curve for each PTTV Time in PTTV_arr (same as PTTVSegments)
  #For each model...
  for i in range(len(PTTV_arr)):
      LightCurves[i].modelnumber = i            #Set model number
      SLCTMInputParams['pttv'] = PTTV_arr[i]    #Set this model to an element of PTTV_arr
      LightCurves[i].SetModelParams(SLCTMInputParams) #Set the (revised) Parameters by passing our parameter dictionary.
      LightCurves[i].setBatmanParams(bmparams,BatmanInputParams) #Set the batman parameters by passing our batman parameter dictionary.
      SLCTM.PopTransTimes(LightCurves[i], NUMBEROFTRANSITS) #Populate NUMBEROFTRANSITS transit times. This fills an array full of transit times.
      SLCTM.PopFluxesNaive_Model(LightCurves[i],DataLightCurve,bmparams) #This populates each transit's light curve using same time points as the data's light curve.
</pre></code>

<h2>Functions</h2>
<h3><a name="TransTimes"></a>SLCTM.PopTransTimes(SLCTM.LightCurve,n)</h3>
<p>This function takes the LightCurve object (named SLCTM), uses its internal parameters (set by member functions SLCTM.LightCurve.SetModelParams and SLCTM.LightCurve.setBatmanParams), and fills a list (SLCTM.LightCurve.transTimes[]) with n transits.</p>
<h3><a name="DataGen"></a>SLCTM.PopFluxesNaive_Data(SLCTM.LightCurve,BatmanParams,NFluxPoints)</h3>
<p>This function takes the list of transits, and populates two lists (SLCTM.LightCurve.fluxes[] and SLCTM.LightCurve.fluxTimes[]) with NFluxPoints per transit. </p>
<h3><a name="ModelGen"></a>SLCTM.PopFluxesNaive_Model(SLCTM.LightCurve{MODEL},SLCTM.LightCurve{DATA},BatmanParams)</h3>
<p>This function takes the fluxTimes[] list, start indices, and end indices for each transit from the data light curve and fills the model light curve's fluxes[] list with the same number of points as the data lightcurve. </p>
<h3><a name="AddNoise"></a>SLCTM.Add_Norm_LCnoise(SLCTM.LightCurve,lcnoise)</h3>
<p>This adds normal noise to the input lightcurve.</p>
<h3><a name="ChiSqComp"></a>SLCTM.ComputeChiSqInter(SLCTM.LightCurve{DATA},SLCTM.LightCurve{MODEL})</h3>
<p>For two LightCurve objects, with aligned timestamps, this function computes the Chi Squared value for the model.</p>
</body>
</html>
